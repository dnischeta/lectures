# Модули в JavaScript

## Введение

_Модульная программирование_ - организация программы как совокупности независимых блоков (модулей), которые взаимодействуют по правилам, определенным конкретной системой модулей.

_Модуль_ - функционально законченный фрагмент программы (на низком уровне модуль ≈ файл).

---

Примеры модулей:

```python
# utils.py
def log(stringToLog):
    print(stringToLog)

# user.py
from utils import log

def processUser(user):
    log(user.name)
```

```php
/* vars.php */
<?php
$color = 'зелёное';
$fruit = 'яблоко';
?>

/* test.php */
<?php
echo "Одно $color $fruit"; // Одно

include 'vars.php';

echo "Одно $color $fruit"; // Одно зелёное яблоко
?>
```

```rust
// A module named `my_mod`
mod my_mod {
    // Items in modules default to private visibility.
    fn private_function() {
        println!("called `my_mod::private_function()`");
    }

    // Use the `pub` modifier to override default visibility.
    pub fn function() {
        println!("called `my_mod::function()`");
    }
}

fn main() {
    my_mod::function(); // called `my_mod::function()`
}

```

---

Наличие системы модулей в языке программирование очень важно, поскольку модульная система решает целый ряд проблем. По сути это инструмент, который как и любой инструмент проявляет себя в лучшем виде при правильном использовании.
При правильном использовании (имеется ввиду правильное распределение кода по модулям, а не синтаксическая правильность) мы получаем следующие преимущества:

1. Снижение сложности в процессе разработки. Разработчик сфокусирован на одном модуле в один момент времени.
   Текущий модуль может использовать другие или использоваться в них сам, но это не имеет значения при его разработке.
2. Граница модуля - граница распространения изменений. Оптимизация, рефакторинг, расширение - все это затрагивает только конкретный модуль (если его интерфейс не изменяется).
3. Упрощение использования ООП, SOLID, принципов GRASP, паттернов GoF (да, это можно делать и без модулей, в одном файле).
4. Очевидное юнит-тестирование, один модуль = один юнит -> один test suite (набор тестов).

Самая важная возможность, которую нам предоставляет модульная система - **УПРАВЛЕНИЕ СЛОЖНОСТЬЮ**. Мы начинаем относится к одному модулю как к какой-то конкретной абстракции и собирать проект из этих абстракций.
Модуль декларирует интерфейс и отвечает за его реализацию, все остальное уже вторично.

---

Как вы могли заметить, среди примеров модульных систем отсутствует пример для JavaScript, как думаете почему?
Если почитать про детство нашего любимого языка, то можно узнать, что изначально спецификация не предоставляла описание модульной системы, ее просто не было (вплоть до [ES6](https://262.ecma-international.org/6.0/#sec-modules), 2015 год).
В самом начале существования JavaScript наличие модульной системы было не критично ([Пересказ истории JS](https://www.youtube.com/watch?v=3-9fnjzmXWA)).

## Эволюция модульной системы в JS

### 0 - Подключение нескольких JS-файлов

Самое простое, что мы можем сделать, - подключить несколько js-файлов:

```html
<html>
  <head>
    <!-- ... -->
  </head>
  <body>
    <!-- ... -->
    <script src="app.js"></script>
    <script src="form-login.js"></script>
  </body>
</html>
```

`app.js`

```js
function init() { ... }

init();
```

`login.js`

```js
function handleLogin() { ... }

form.addEventListener('submit', handleSubmit);
```

**Плюсы**:

- простота реализации.

**Минусы**:

- нет изоляции:
  - все определения (функции, идентификаторы) доступны на глобальном объекте `window` (загрязнение глобальной области видимости);
  - любой скрипт может изменить функциональность, которую предоставляет другой скрипт.
- все файлы нужно подключать непосредственно в `html`;
- использование глобального объекта для переиспользования кода.

### 1 - Добавляем изоляцию

Последующим улучшением может быть добавление изоляции. Нам нужен механизм, который позволит скрыть область видимости модуля от внешнего мира. В качестве этого механизма мы будем использовать обычную функцию (функция создает область видимости, которая не доступна за ее пределами).

```html
<html>
  <head>
    <!-- ... -->
  </head>
  <body>
    <!-- ... -->
    <script src="app.js"></script>
    <script src="form-login.js"></script>
  </body>
</html>
```

`app.js`

```js
var APP = {};
```

`login.js`

```js
function initizlieLoginModule() {
    var somePrivateVar = { ... };

    function initializeLogin() { ... }

    APP.initializeLogin = initializeLogin;
}

initizlieLoginModule();
```

Таким образом у каждого модуля есть возможность защитить свою реализацию и предоставить во вне только конкретную функциональность.

**Плюсы**:

- простота реализации;
- изоляция.

**Минусы**:

- порядок подключения скриптов стал важен (скрипт `login.js` полагается на то, что `window.APP` существует);
- загрязнение глобального объекта (`window.initializeLoginModule`);
- использование глобального объекта для переиспользования кода;
- необходимость оборачивать каждый модуль в функцию.

### 2 - Паттерн модуль

Для дальнейшего продвижения нам нужно вспомнить про **IIFE**.
**IIFE (Immediately invoked function expression)** - функция, которая вызывается при создании.

```js
(function () {
  console.log("IIFE called!");
})();
```

Если мы добавим использование IIFE в предыдущий пример, то мы избавимся от загрязнения глобального объекта функциями, которые нужны для инициализации модулей.

`login.js`

```js
(function() {
    var privateVariable = { ... };

    function initializeLogin() { ... }

    APP.initializeLogin = initializeLogin;
})();
```

Мы немного улучшили нашу модульную систему, такой паттерн называется [Модуль](https://metanit.com/web/javascript/3.9.php).

**Плюсы**:

- простота реализации;
- изоляция.

**Минусы**:

- порядок подключения скриптов стал важен (скрипт `login.js` полагается на то, что `window.APP` существует);
- использование глобального объекта для переиспользования кода;
- необходимость оборачивать каждый модуль в функцию.

### 3 - кастомные решения...

В силу отсутствия стандартизации все писали свои реализации модульных систем под свои нужды. Для нас это не так важно, но ознакомится подробнее можно в [статье](https://habr.com/ru/company/yandex/blog/192874/). Нужно двигаться в сторону стандартизации.

### 4 - CommonJS

Параллельно с развитием браузерного JS происходило и развитие платформ для серверной разработки с использованием JavaScript. Было создано сообщество, которое занималось API серверного JavaScript, в итоге появилась спецификация CommonJS modules (CJS, CommonJS), которая в конечном счете была реализована в Node.js. Особенностью этой системы модулей является то, что все модули загружаются синхронно (это не подходит для использования в браузере).

`module-a.js`

```js
var count = 5;

module.exports = count;
```

`module-b.js`

```js
const count = require("./module-a.js");

// Сделать что-то с count
```

**Плюсы**:

- наконец-то есть [спецификация](http://wiki.commonjs.org/wiki/Modules/1.1);
- изоляция;
- не используется глобальный объект для переиспользования кода.

**Минусы:**

- не работает в браузере (необходимо использовать сборщик);
- все модули загружаются синхронно.

### 5 - AMD

В ходе обсуждения и разработки спецификации CommonJS выдвигались идеи и предложения, касающиеся асинхронной загрузки модулей. В CommonJS асинхронная загрузка модулей так и не была добавлена. В итоге появился еще один стандарт модулей - [AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md) (Asynchronous module definition). Он позволяет загружать модули асинхронно:

`module-a.js`

```js
define(function() {
    function publicFunction() { ... }

    return { publicFunction };
});
```

`module-b.js`

```js
define(["./module-a"], function (moduleA) {
  moduleA.publicFunction();
});
```

В итоге AMD продолжила свое существование отдельно от CJS. Скорее всего, вам не придется использовать AMD в процессе разработки, но вы все еще можете встретится с этой системой модулей.

### 6 - UMD

CJS и AMD не могли исполнятся в одних средах и не планировали объединятся, тем временем популярность CJS росла из-за низкого порога входа, роста популярности Node.js и появления сборщика Browserify. Для переносимости кода между системами модулей был разработан паттерн [UMD (Universal module definition)](https://github.com/umdjs/umd).

```js
(function (define) {
  define(function () {
    var helloInLang = {
      en: "Hello world!",
      es: "¡Hola mundo!",
      ru: "Привет, мир!",
    };

    return {
      sayHello: function (lang) {
        return helloInLang[lang];
      },
    };
  });
})(
  typeof module === "object" && module.exports && typeof define !== "function"
    ? function (factory) {
        module.exports = factory();
      }
    : define
);
```

Если необходимо использовать библиотеку как в браузере, так и в Node.js, то стоит использовать UMD.

### 7 - ES modules

До появления ES modules ситуация обстояла так:

- В Node.js используем CommonJS модули;
- В браузере используем AMD/UMD/CommonJS -> сборщик -> AMD/UMD;

В 2015 году была выпущена спецификация ECMAScript6 (ES6), которая содержала описание того, как должны работать модули. Наконец-то у нас появился стандарт.

`module-a.js`

```js
var count = 5;

export default count;
```

`module-b.js`

```js
import count from "./module-a.js";

// Сделать что-то с count
```

Возможности этой системы модулей мы рассмотрим ниже. Таким образом, у нас остается две основных системы модулей, которые мы используем:

- ES modules в браузерах (см. поддержку конкретного браузера);
- CommonJS в Node.js (использование ESM возможно при некоторой конфигурации начиная с версии 13.2.0).

## CJS

Рассмотрим подробно, как работает CommonJS. Как было сказано ранее, CJS был стандартизирован ([спецификация](http://wiki.commonjs.org/wiki/Modules/1.1)) и реализован в Node.js. При работе в среде Node.js вы неизбежно столкнетесь с CJS. Сделаем обзор синтаксиса и возможностей этой системы модулей.

Для экспорта сущностей из модуля используется объект `module.exports`.

`logger.js`

```js
const LOGGER = { ... };

function log(string) { ... }

module.exports = {
    LOGGER,
    log
};
```

Для использования сущностей, которые мы экспортировали, нужно их импортировать в том модуле, где мы хотим их использовать. Для этого используется функция `require`.

`service.js`

```js
const loggerModule = require("./logger.js");

// loggerModule.LOGGER
// loggerModule.log

const { LOGGER, log } = require("./logger.js"); // мы можем использовать деструктуризацию

// LOGGER
// log
```

CJS позволяет использовать модули, которые мы установили в проект через [npm](https://www.npmjs.com/). Для этого мы используем название npm-пакета при вызове `require`.

`index.js`

```js
const express = require("express");
```

---

Мы разобрались с основами CJS. Но откуда в нашем модуле появляются `require` и `module`, в спецификации языка их нет. Как мы говорили ранее, CJS был разработан в ходе разработки платформ для запуска JavaScript вне браузера. Таким образом, предоставлением модульной системы занимается сама платформа, в которой мы запускам наш код (Node.js). Реализация довольно проста и об этом можно почитать в документации [Node.js](https://nodejs.org/api/modules.html#the-module-wrapper).

```js
(function (exports, require, module, __filename, __dirname) {
  // Module code actually lives in here
});
```

Node.js берет на себя оборачивание модулей, которые мы пишем внутрь функции (помните паттерн "Модуль"?). Таким образом обеспечивается изоляция модуля и предоставление модулю `require` и `module`. `exports` это тот же объект что и `module.exports`, что именно использовать определяется код-стайлом внутри проекта.

---

### `require.cache`

Представляет собой объект, в котором кэшируются импортированные ранее модули. При удалении записи из `require.cache` модуль будет загружен заново при его импорте.

### `require.resolve`

Функция, которая возвращает абсолютный путь до конкретного модуля. Работает с файловой системой для поиска конкретного файла, разрешает пути относительно файла, из которого вызвана. [Документация](https://nodejs.org/api/modules.html#requireresolverequest-options).

```js
require.resolve("./module-a.js"); // /Users/user/dir/proj/src/module-a.js
```

### `module`

Объект `module` предоставляет много полезных полей, подробнее можете ознакомиться в [документации](https://nodejs.org/api/modules.html#the-module-object).

## ESM

В 2015 году организацией ECMA была выпушена [6-ая версия спецификации ECMAScript](https://262.ecma-international.org/6.0/), которая содержала описание системы модулей. Были описаны два новых ключевых слова `import` и `export`, которые используются для создания импорт/экспорт - statement'ов (нормального перевода слова statement я не подобрал). Рассмотрим возможные statement'ы, опираясь на соответствующие таблицы ([import statements](https://262.ecma-international.org/6.0/#table-40), [export statements](https://262.ecma-international.org/6.0/#table-42)) из спецификации.

Note:

`ImportEntry = { [[ModuleRequest]], [[ImportName]], [[LocalName]] }`

`[[ModuleRequest]]` - строка, которая является _именем модуля_ (эта формулировка использована для упрощения).
`[[ImportName]]` - имя, под которым целевой модуль экспортирует значение. Если в качестве имени используется `"*"`, то импорт запрашивает namespace-объект целевого модуля.
`[[LocalName]]` - идентификатор, который будет использоваться для доступа к значению внутри импортирующего модуля.

| Import Statement Form         | `[[ModuleRequest]]`                  | `[[ImportName]]` | `[[LocalName]]` |
| ----------------------------- | ------------------------------------ | ---------------- | --------------- |
| `import v from "mod";`        | `"mod"`                              | `"default"`      | `"v"`           |
| `import * as ns from "mod";`  | `"mod"`                              | `"*"`            | `"ns"`          |
| `import {x} from "mod";`      | `"mod"`                              | `"x"`            | `"x"`           |
| `import {x as v} from "mod";` | `"mod"`                              | `"x"`            | `"v"`           |
| `import "mod";`               | An ImportEntry Record is not created |

| Export Statement Form            | `[[ExportName]]` | `[[LocalName]]` |
| -------------------------------- | ---------------- | --------------- |
| `export var v;`                  | `"v"`            | `"v"`           |
| `export default function f() {}` | `"default"`      | `"f"`           |
| `export default function() {}`   | `"default"`      | `"*default*"`   |
| `export default 42;`             | `"default"`      | `"*default*"`   |
| `export {x};`                    | `"x"`            | `"x"`           |
| `export {v as x};`               | `"x"`            | `"v"`           |

_Note: `"*default*"` - синтетическое имя, которое используется в спецификации для ссылки на анонимные экспорты. Таким образом, при дефолтном экспорте анонимной функции/значения, мы не можем обратиться к значению внутри модуля._

P.S. в данной лекции мы не будем рассматривать механизм ре-экспортов.

Спецификация также предоставляет описание алгоритмов, в соответствии с которыми должно происходить разрешение импортов и экспортов, мы же не будем углубляться в них, рассмотрим более конкретный пример.

`index.js`

```js
import consoleLogger, { Logger } from './Logger.js';

const sentryLogger = new Logger(sentryIo);

consoleLogger.log(...);

if (PRODUCTION) {
    sentryLogger.log(...);
}
```

`Logger.js`

```js
export class Logger {
  constructor(io) {
    this.io = io;
  }
}

export default new Logger(console);
```

---

На этом мы можем закончить обзор основных возможностей ESM. Но стандарты не стоят на месте, в 2020 году в спецификацию [ES11](https://262.ecma-international.org/11.0/) было добавлено описание динамического импорта. Коротко говоря, у нас появилась возможность дожидаться загрузки модулей и импортировать модули по условию.

```js
import('./module-a.js').then(moduleA => { ... });

if (Math.random() > 0.5) {
    import('./module' + '-a.js').then(moduleA => { ... });
}
```

### `import.meta`

Помимо основной функциональности ключевое слово `import` дает нам возможность обратиться к его полю `meta`. В объекте есть одно поле `url`, которое соответствует url текущего модуля.

`index.js`

```js
console.log(import.meta); // { url: 'http://127.0.0.1:5500/index.js' }
```

## CJS vs ESM

Для полноты картины рассмотрим и сравним особенности работы CJS и ESM.

### Поддержка

Скорее всего, вы работаете преимущественно в двух средах: браузер и Node.js.

1. Браузер

   - **ESM**
     В настоящее время большинство современных браузеров поддерживают es модули, можно убедиться [здесь](https://caniuse.com/?search=type%3D%22module%22). Для того, чтобы использовать ключевые слова `import` и `export` в наших скриптах, нужно добавить атрибут `type="module"` при подключении скрипта.

     ```html
     <script type="module" src="index.js"></script>
     ```

     Если вы хотите использовать ESM на продакшене, то стоит убедиться, что целевая платформа поддерживает ее и корректно настроить сборщик.

   - **AMD/UMD**

     Если по какой-то причине вы не можете использовать ESM на продакшене, то у вас не остается альтернатив кроме как AMD/UMD. Используйте UMD только в случае, если выш код может исполнятся и в браузере и на сервере (например вы пишите библиотеку утилит, которые планируете использовать и на клиенте и на сервере). Современные сборщики позволят вам писать код, используя ESM, собирают проект, осуществляя трансформацию ESM -> AMD/UMD.

2. Node.js

   - **CommonJS**

     CommonJS является "родной" системой модулей для Node.js, поэтому работает внутри этой среды по умолчанию.

   - **ESM**

     ESM можно использовать внутри Node.js, но необходима дополнительная конфигурация:

     - критерием, по которому определяется тип модуля является расширение файла: `.cjs` <-> CJS, `.mjs` <-> ESM;
     - для файлов с расширением `.js` используется поле `"type"` из package.json (по умолчанию `"commonjs"`).

   Информация о том, как корректно поставлять библиотеки для использования той или иной системой модулей будет добавлена в дальнейших обновлениях. Пока можно посмотреть [лекцию](https://www.youtube.com/watch?v=31sX_3IbXs4).

### Совместимость в Node.js

При работе в Node.js стоит помнить о некоторых особенностях. Находясь внутри ES модуля мы можем импортировать значения из CommonJS модуля.

- при работе в CJS модулях мы можем подключать и CJS модули (`require(...)`) и ESM модули (только через `import(...)`). В таком случае код становится асинхронным (`import(...)` возвращает промис);
- в CJS модулях не доступен [top level await](https://github.com/tc39/proposal-top-level-await);
- в ESM мы можем подключать и CJS и ESM модули одинаково, через `import`. Но если нам нужна ленивая загрузка модулей, то придется использовать `import(...)`, код снова становится асинхронным (но нам доступен top level await для Node.js начиная с 14.8);
- в ESM нет `__dirname` и `__filename` (их можно посчитать самостоятельно, используя `import.meta.url`);
- ESM не позволяет загружать json-файлы, для этого придется использовать пакет `fs` (в CJS можно было так `const data = require('./data.json')`);
- в ESM отсутствуют `require.resolve`, `require.mail` и `require.cache`.

Не для каждого проекта перечисленные особенности являются проблемами, но стоит о них знать при выборе системы модулей для Node.js приложения.

## Ресурсы

1. [Википедия](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5);
2. [ECMA-262](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/);
3. [Эволюция модульной системы JS, видео](https://www.youtube.com/watch?v=qJWALEoGge4);
4. [Эволюция модульного JavaScript](https://habr.com/ru/company/yandex/blog/192874/);
5. [Статья про ESM](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/);
6. [Node.js modules](https://nodejs.org/api/modules.html#the-module-wrapper);
7. [ECMAScript 6](https://262.ecma-international.org/6.0/);
8. [Node.js модули и пакеты формата ECMA и CommonJS, использование package.json и node_modules](https://www.youtube.com/watch?v=31sX_3IbXs4);
9. [Node.js модули: ECMA, Common.js, Module API](https://www.youtube.com/watch?v=CJr2vS3hjMU)
